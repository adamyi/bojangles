# -*- coding: utf-8 -*-
"""Bojangles GA Algorithm PoC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sei9n9P8ZAuqFboRYmHx_nULnfwVLMzc
    
By Adam Yi <i@adamyi.com> and Chester Pang <i@bopa.ng>
"""

import json
import sys
import random
import matplotlib.pyplot as pyplot


# GA variables
POP_SIZE    = 20
GENERATIONS = 5000
MUTATION_CHANCE = 100



# read data

def read_data(ccodes):
    """
    Read classutil.json and return list of comps (each containing classes)
    Given input of a list of course codes
    """
    with open('classutil.json') as f:
        data = json.load(f)

    courses = []

    for ccode in ccodes:
        # spec_name = ccode[0:4]
        # spec = (spec for spec in data if spec["specialisation"] == spec_name and spec["session"] == 'S2').next()
        # courses.append((course for course in spec["courses"] if course["course"] == ccode).next())
        courses.append(data[ccode])

    # print(json.dumps(courses, indent = 4))


    # output: comps = [[cls for classes in unique comp]]
    comps = []
    for course in courses:
      course_comp = []
      for cls in course['classes']:
        course_comp.append(cls['comp'])
      for comp in set(course_comp):
        comps.append([cls for cls in course['classes'] if cls['comp'] == comp])
        
    return comps



# Fitness Function

def clash_hours(comps, dna):
  """
  Return hours clashed given provided DNA.
  """
  DAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']
  occupied = {day: [] for day in DAYS}
  ret = 0
  for i in xrange(len(comps)):
    for time in comps[i][dna[i]]['times']:
      if not time['hours']: #e.g. web lectures
        continue
      # TODO: deal with time with minutes (e.g. 11:30)
      for hr in range(int(time['hours']['start']), int(time['hours']['end'])):
        if hr in occupied[time['day']]:
          ret += 1
        occupied[time['day']].append(hr)
  return ret
    
def fitness(comps, dna):
  """
  Where the magic happens.

  The evaluation function of a class schedule (dna).
  The bigger the fitness value, the better the class schedule is.

  TODO: make this really fancy
  """
  return 1.0/(clash_hours(comps, dna) + 1)

# GA algorithm

def random_int(size):
  """
  Return a random int from 0 to size - 1
  """
  return random.randint(0,size - 1)

def random_population(comps):
  """
  Return the initial random population of DNAs by randomizing.
  """
  pop = []
  for i in xrange(POP_SIZE):
    dna = []
    for c in xrange(len(comps)):
      dna.append(random_int(len(comps[c])))
    pop.append(dna)
  return pop

def roulette_select(dnas):
  """
  Choose a random dna by imitating the process of finding a girlfriend with
  standards gradually lowered.
  
  Disclaimer: this might not be a universal fact for finding your loved one.
  We are not responsible for using this algorithm to find a date. Use at your
  own risk ^_^

  * This is actually an O(n) approach to the Fitness Proportionate Selection
  * problem.
  """
  fitness_total = sum((dna[1] for dna in dnas))
  criteria = random.uniform(0, fitness_total)
  for dna, fitness in dnas:
    if criteria < fitness:
      return dna
    criteria -= fitness

  return dna

def crossover(dna1, dna2):
  """
  Slices two DNAs at a random index and swaps one part to generate two newborn
  DNAs.
  """
  pos = int(random.random() * len(dna1))
  return (dna1[:pos] + dna2[pos:], dna2[:pos] + dna1[pos:])

def mutate(comps, dna):
  """
  Copy a DNA while randomly mutating it with chance 1/MUTATION_CHANCE
  """
  dna_out = []
  for gl in xrange(len(comps)):
    if int(random.random() * MUTATION_CHANCE) == 1:
      dna_out.append(random_int(len(comps[gl])))
    else:
      dna_out.append(dna[gl])
  return dna_out

if __name__ == "__main__":

  if (len(sys.argv) == 1):
    print("Usage: ./%s COMP1511 MATH1131......" % sys.argv[0])
    sys.exit(1)

  comps = read_data(sys.argv[1:])

  population = random_population(comps)
  fits = []

  for generation in xrange(GENERATIONS):
    try:
      max_fit = max(weighted_population, key=lambda pair: pair[1])
      fits.append(max_fit)
      print "Generation %s: max_fit = '%s'" % (generation, json.dumps(max_fit))
    except:
        pass


    weighted_population = [[dna, fitness(comps, dna)] for dna in population]
    population = []

    for _ in xrange(POP_SIZE / 2):
      # Selection
      dna1 = roulette_select(weighted_population)
      dna2 = roulette_select(weighted_population)

      # Crossover
      dna1, dna2 = crossover(dna1, dna2)

      # Mutate and add back into the population.
      population.append(mutate(comps, dna1))
      population.append(mutate(comps, dna2))

  weighted_population = [[dna, fitness(comps, dna)] for dna in population]
  fittest_schedule = max(weighted_population, key=lambda pair: pair[1])

  fits.append(fittest_schedule)
  print "Fittest in all gens: %s" % json.dumps(max(fits, key=lambda pair: pair[1]))

  x = range(len(fits))
  pyplot.plot(x,[pair[1] for pair in fits])
  pyplot.show()

